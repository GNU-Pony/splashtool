#!/usr/bin/env python3
# -*- python -*-
'''
splashtool – A simple tool for creating SYSLINUX splashes without fuss

Copyright © 2013, 2014  Mattias Andrée (maandree@member.fsf.org)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
'''

import sys


def join(fg, bg, alpha):
    t = alpha * linear(fg) + (255 - alpha) * linear(bg)
    t /= 255
    if t <= 0.00304:
        t *= 12.92
    else:
        t = 1.055 * t ** (1 / 2.4) - 0.055
    return int(255 * t + 0.5)

def linear(c):
    if c <= 10:
        return c / (255 * 12.92)
    return ((c + 14.025) / 269.025) ** 2.4

def subpixels(p):
    return ((p >> 24) & 255, (p >> 16) & 255, (p >> 8) & 255, (p >> 0) & 255)

def buffer_join(layer, base, offx, offy):
    for x in range(len(layer)):
        if x + offx >= len(base):
            break
        layer_column = layer[x]
        base_column = base[x + offx]
        for y in range(len(column)):
            if y + offy >= len(base_column):
                break
            (la, lr, lg, lb) = subpixels(layer_column[y])
            (ba, br, bg, bb) = subpixels(base_column[y + offy])
            r = join(lr, br, la)
            g = join(lg, bg, la)
            b = join(lb, bb, la)
            base_column[y + offy] = (255 << 24) | (r << 16) | (g << 8) | b

def widescreen(img):
    rc = [[0] * (480 * 16 // 9) for i in range(480)]
    for y in range(480):
        e = 0
        for x in range(640):
            rc[x + e][y] = img[x][y]
            if x % 3 == 2:
                argb = img[x][y]
                if x < 639:
                    (a1, r1, g1, b1) = subpixels(argb)
                    (a2, r2, g2, b2) = subpixels(img[x + x1][y])
                    a = ((a1 + a2) // 2) << 24
                    r = ((r1 + r2) // 2) << 16
                    g = ((g1 + g2) // 2) << 8
                    b = ((b1 + b2) // 2) << 0
                    argb = a | r | g | b
                e += 1
                rc[x + e][y] = argb
    return rc

# Read image data.
splash = input()
width  = int(input())
height = int(input())
rows   = [input() for i in range(height)]

# Read font data.
chars = int(input())
charx = int(input())
chary = int(input())
charmap = [[0] * chary for i in range(chars)]
for i in range(chars):
    for y in range(chary):
        line = input()
        charmap[i][y] = sum((0 if line[x] == ' ' else 1) << x for x in range(charx))

# The overlay should be centered on the background.
offx = (640 - width * charx) // 2
offy = (480 - height * chary) // 2

# Buffers for layers.
# TODO splash = ... (splash)
background = [[0] * (height * chary) for i in range(width * charx)]
foreground = [[0] * (height * chary) for i in range(width * charx)]
shadow     = [[0] * (height * chary) for i in range(width * charx)]

# Colours.
fore = 0
back = 0
foreback = 0

# Fill largers.
for y in range(height):
    x = 0
    row = rows[y]
    escape = False
    for i in range(len(row)):
        c = row[i]
        if c == '\033':
            fore = foreback >> 32
            back = foreback & ((1 << 32) - 1)
            escape = not escape
            foreback = 0
        elif escape:
            if c == '#':
                continue
            foreback <<= 4
            foreback |= (ord(c) & 15) + (0 if c <= '9' else 9)
            foreback &= (1 << 64) - 1
        else:
            ci = ord(c) % chars
            if   c == '┌':  ci = 218
            elif c == '─':  ci = 196
            elif c == '┐':  ci = 191
            elif c == '│':  ci = 179
            elif c == '├':  ci = 195
            elif c == '┤':  ci = 180
            elif c == '└':  ci = 192
            elif c == '┘':  ci = 217
            char = charmap[ci]
            for yi in range(chary):
                for xi in range(charx):
                    xo = (char[yi] >> xi) & 1
                    t = offx + x * charx + xi + xo
                    rgb = splash[639 if t > 639 else t][offy + y * chary + yi]
                    _a, r, g, b = subpixels(rgb)
                    if xo == 1:
                        shadow[x * charx + xi][y * chary + yi] = 128 << 24
                    (c_, i_) = (fore, foreground) if xo == 1 else (back, background)
                    ca, cr, cg, cb = subpixels(c_)
                    r = join(cr, r, ca)
                    g = join(cg, g, ca)
                    b = join(cb, b, ca)
                    rgb = (255 << 24) | (r << 16) | (g << 8) | b
                    i_[x * charx + xi][y * chary + yi] = rgb
            x += 1

# Apply layers.
buffer_join(background, splash, offx, offy)
buffer_join(shadow, splash, offx + 1, offy + 1)
buffer_join(foreground, splash, offx, offy)

# Make widescreen preview.
if sys.argv[2].lower().startswith('-w') or sys.argv[2].lower().startswith('--w'):
    splash = widescreen(splash)

# Print image.
width, height = len(splash), len(splash[0])
print('P3')
print('%i %i' % (width, height))
print('255')
trans = ['%i' % i for i in range(256)]
for y in range(height):
    for x in range(width):
        print(trans[splash[x][y]])

