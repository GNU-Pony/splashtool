#!/bin/bash
# 
# splashtool – A simple tool for creating SYSLINUX splashes without fuss
# 
# Copyright © 2013, 2014  Mattias Andrée (maandree@member.fsf.org)
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
# 
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


in="$(realpath "$1")"
out="$(realpath "$2")"
d="$(dirname "$(realpath "$0")")"

cd "$(dirname "$1")"


# Get the description text do display.
get_text ()
{
    awk 'BEGIN { text = 0; }
         { t=tolower($1);
           if (t=="endtext") text+=1;
           if (text==1) print $LINE;
           if (t=="text") text+=1;
         }'
}

# Default values.
default_data ()
{
    cat <<EOF
TIMEOUT 0
MENU TITLE 
MENU BACKGROUND splash.png
MENU FONT /usr/share/kbd/consolefonts/default8x16.psfu.gz
MENU WIDTH 78
MENU MARGIN 3
MENU ROWS 12
MENU VSHIFT 0
MENU TIMEOUTROW 18
MENU TABMSGROW 18
MENU HELPMSGROW 22
MENU HELPMSGENDROW 29
MENU COLOR border      _ #ff808080 #00000000 _
MENU COLOR title       _ #ffffffff #00000000 _
MENU COLOR sel         _ #ff808080 #ffd0a290 _
MENU COLOR unsel       _ #ffffffff #00000000 _
MENU COLOR help        _ #ffffffff #00000000 _
MENU COLOR timeout_msg _ #ffffff00 #00000000 _
MENU COLOR timeout     _ #ffffff00 #00000000 _
MENU COLOR tabmsg      _ #ffffff00 #00000000 _
EOF
}

# Select variable
sel ()
{
    prefix="$(echo "${data}" | grep -io "^${1} " | sed 1q)"
    echo "${data}" | grep -i "^${1} " | sed -e "s/^${prefix}//;q" | sed -e 's/^ *//'
}

# Select colour variable
csel ()
{
    if [ -z "${debug}" ]; then
	sel "${1}" | sed -e 's/^\([^ ][^ ]*\)  *\([^ ][^ ]*\)  *\([^ ][^ ]*\).*/\2\3/g'
    else
	sel "${1}" | sed -e 's/^\([^ ][^ ]*\).*/\1/g'
    fi
}

# Truncate the number of lines, and fill in missing lines
ltrunc ()
{
    (cat ; awk "BEGIN { for (i=0; i<${1}; i++) print \" \"; }") | sed ${1}q
}

# Truncate the number of columns, and fill in missing columns
ctrunc ()
{
    spaces="$(printf "%${1}s" "")"
    sed -e 's/$/'"${spaces}"'/' | grep -Po "^$(echo "${spaces}" | sed -e 'y/ /./')"
}

# Add columns the left side
padl ()
{
    while read -r l; do printf "%${1}s%s\n" "" "${l}"; done
}

# Colourise text
cset ()
{
    sed -e 's/^/\x1b'"$(csel "${1}")"'\x1b/' -e 's/$/\x1b\x1b/'
}

data="$(sed -e 's/\t/ /g' < "$in" | sed -e '/^ *\(#\|$\)/d' -e 's/ # .*$//' -e 's/^ *//' -e 's/ *$//')"
helptext="$(echo "${data}" | get_text)"
data="$((default_data ; echo "${data}") | grep -Pi '^(timeout|menu|font) ' | tac)"
data="$(echo "${data}" | sed -e 's/^MENU //' -e 's/^COLOR /COLOR_/')"
labels="$(echo "${data}" | tac | grep -i '^label ' | sed -e 's/^..... //')"

export data

export font="$(sel font)"
export width="$(sel width)"
export vshift="$(sel vshift)"
export helpmsgendrow="$(( $(sel helpmsgendrow) - ${vshift} ))"
export helpmsgrow="$(sel helpmsgrow)"
export menumargin=$(( (${width} - 70) / 2 ))
export border="$(csel color_border)"

(
echo "$(sel background)"
echo "${width}"
echo "29"

labels="$(echo "${labels}" | ltrunc "$(sel rows)" | sed -e 's/^/ /' | ctrunc 68)"
labels="$(echo "${labels}" | sed -e 1q | cset color_sel ; echo "${labels}" | sed -e 1d | cset color_unsel)"

title="$(echo "${title}" | padl $(( (68 - $(echo -n "${title}" | wc -c)) / 2 )) | ctrunc 68 | cset color_title)"

helptext="$(echo "${helptext}" | ltrunc $(( ${helpmsgendrow} - ${helpmsgrow} + 1 )) | padl $(sel margin))"
helptext="$(echo "${helptext}" | ctrunc "${width}" | cset color_help)"

text_ ()
{
    line="$(printf "%68s" "" | sed -e 's/ /─/g')"
    echo "┌${line}┐"
    echo $'│\e\e'"${title}"$'\e'"${border}"$'\e│'
    echo "├${line}┤"
    sed -e 's/^/│\x1b\x1b/' -e 's/$/\x1b'"${border}"'\x1b│/'
    echo "└${line}┘"
}

add_more ()
{
    echo "${more}" ; echo "${1}" | sed -e "s/^/"$(( $(sel ${2}) * 10 + ${3} ))" /"
}

text="$(echo "${labels}" | text_ | cset color_border | padl ${menumargin})"
text="$(awk "BEGIN { for (i=0; i<${vshift}; i++) print \" \"; }" ; echo "${text}")"

export more=""

if [ ! "$(sel timeout)" = 0 ]; then
    timeout=$(( $(sel timeout) / 10 ))
    timeoutmsg_="Automatic boot in ${timeout} seconds"
    timeoutmsg_=$(( (${width} - $(echo -n "${timeoutmsg_}" | wc -c)) / 2 ))
    timout=$'\e'"$(csel color_timeout)"$'\e'"${timeout}"$'\e'"$(csel color_timeout_msg)"$'\e'
    timeoutmsg="Automatic boot in ${timeout} seconds"
    timeoutmsg="$(echo "${timeoutmsg}" | cset color_timeout_msg | padl ${timeoutmsg_})"
    export more="$(add_more "${timeoutmsg}" timeoutrow 0)"
fi

tabmsg="Press [Tab] to edit options"
tabmsg="$(echo "${tabmsg}" | padl $(( (${width} - $(echo -n "${tabmsg}" | wc -c)) / 2 )) | cset color_tabmsg)"
export more="$(add_more "${tabmsg}" tabmsgrow 1)"
export more="$(add_more "${helptext}" helpmsgrow 2)"
more="$(echo "${more}" | sed -e 1d | sort -n -s -k 1,1)"

export text
segs ()
{
    line=$(( $(echo "${text}" | wc -l) - $(sel vshift) ))
    last=0
    mod=0
    while read -r seg; do
	current=$(echo "${seg}" | cut -d ' ' -f 1)
	index=$(( ${current} / 10 ))
	seg="$(echo "${seg}" | sed -e 's/^[^ ]* //')"
	if [ ${last} = ${current} ]; then
	    text="$(echo "${text}" ; echo "${seg}")"
	    line=$(( ${index} + 1 ))
	elif (( ${line} <= ${index} )); then
	    if (( ${line} < ${index} )); then
		text="$(echo "${text}" ; echo -n | ltrunc $(( ${index} - ${line} )) ; echo "${seg}")"
	    else
		text="$(echo "${text}" ; echo "${seg}")"
	    fi
	    line=$(( ${index} + 1 ))
	fi
	last=${current}
    done
    echo "${text}"
}
text="$(echo "${more}" | segs | ltrunc 30)"

if [ -z "${debug}" ]; then
    echo "${text}"
    (
	if echo "${font}" | grep -i '.gz$' 2>/dev/null >/dev/null; then
	    psf2txt <(gunzip < "${font}") /dev/stderr
	else
	    psf2txt "${font}" /dev/stderr 
	fi
    ) 2>&1 >/dev/null | grep -v ++
else
    echo "${text}" | sed -e 's/\x1b\([^\x1b]*\)\x1b/\x1b[\1m/g'
fi

) # | java -cp "$d" Assemble "$out" "$3"

